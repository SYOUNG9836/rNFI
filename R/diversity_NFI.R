#' Calculates species diversity indices
#' 
#' @description
#' diversity_NFI() is a function that calculates species richness, evenness and the Shannon and Simpson diversity indices for each plot, the entire study area, or groups within the study area.
#' It can calculate diversity at the species or genus level for tables such as trees and saplings.
#' please refer to the \code{\link[vegan]{diversity}} function in the \pkg{vegan} package.
#' Users can specify whether to include large tree survey plots, to focus only on tall trees and Stocked land, and to treat cluster plots as single plots.
#' Users can also group diversity indices by plot characteristics.
#' 
#' @details
#' Species richness refers to the total number of species surveyed.
#' The Shannon-Wiener index, a species diversity index, is the sum of the proportions of the number of individuals or the basal area of a specific species relative to the total number of individuals or the total basal area surveyed. 
#' The Gini-Simpson index is calculated by subtracting Simpson's index from 1, and it ranges between 0 and 1. The value increases as diversity increases.
#' Species evenness, is calculated by dividing the species diversity by the maximum species diversity, and it ranges between 0 and 1. It has a maximum value of 1 when all species are evenly distributed.
#' The function also estimates the mean and standard error of diversity.
#' 
#' @param data : A `list` generated by \code{\link{read_NFI}} that contains 'plot' and one of ('tree', 'herb', 'veg', 'sapling') data frames.
#' @param sp : A character vector; the column name of tree species. e.g., SP, Genus.
#' @param table : A character vector; the target table for which diversity is to be calculated. Must be one of 'tree', 'herb', 'veg', 'sapling'.
#' @param basal : A logical flag; whether to calculate species diversity for trees using basal area or number of individuals.
#' @param grpby : A character vector; variables from 'plot' tables for grouping. Use \code{c()} to combine multiple variables.
#' @param byplot : A logical flag; whether to calculate for each plot separately or for the entire dataset.
#' @param clusterplot : A logical flag; whether to calculate for cluster plot collectively or calculate for each subplot separately.
#' @param largetreearea : A logical flag; whether to include a large tree plot as well, or only a tree plot.
#' @param Stockedland : A logical flag; whether to include only stocked land or also include other types of land.
#' @param talltree : A logical flag; whether to include only tall trees or also shrubs.
#' 
#' @return A `data.frame` that includes diversity indices
#' 
#' @note 
#' The 'herb', 'veg', and 'sapling' tables may contain a lot of errors, so please consider whether to use them.
#' 
#' @examples
#' \dontrun{
#' diversity_NFI(NFI5, sp="SP", table="tree", basal=TRUE)
#' }
#' 
#' @seealso
#' \code{\link[vegan]{diversity}} for calculating the Shannon and Simpson diversity indices.
#' 
#' @references
#' Shannon, C. E. (1948). A mathematical theory of communication. The Bell System Technical Journal, 27(3), 379–423.
#' Simpson, E. H. (1949). Measurement of diversity. Nature, 163(4148), 688–688.
#' Pielou, E. C. (1966). The measurement of diversity in different types of biological collections. Journal of Theoretical Biology, 13, 131–144.
#' 
#' @export 


##  

diversity_NFI <- function(data, sp="SP", table="tree", basal=FALSE, grpby=NULL, byplot=FALSE, clusterplot=FALSE, largetreearea=FALSE, Stockedland=TRUE, talltree=TRUE){
  
  ## error message-------------------------------------------------------------- 
  if(!table %in%  c('tree', 'herb', 'veg', 'sapling')){
    stop("param 'table' must be one of 'tree', 'herb', 'veg', 'sapling'")
  }
  
  required_names <- c("plot", table)
  
  if (!all(required_names %in% names(data))) {
    missing_dfs <- required_names[!required_names %in% names(data)]
    stop("Missing required data frames in the list: ", paste(missing_dfs, collapse = ", "), call. = FALSE)
  }
  
  
  if (!is.null(grpby)){
    if(!is.character(grpby)) {
      stop("param 'grpby' must be 'character'")
    }
    if(any(!grpby %in% names(data$plot))){
      stop(paste0("param 'grpby': ", grpby," is not a column name in the 'plot' data frame."))
    }
  }
  
  if(!sp %in% names(data[[table]])){
    stop(paste0("param 'sp': ", sp," is not a column name in the '", table,"' data frame."))
  } 
  
  
  if (table != "tree"){
    if(basal) {
      warning("param 'basal' must be 'FALSE' if param 'table' is ", table)
    }}
  
  
  
  
  ## Preprocessing-------------------------------------------------------------- 
  if(clusterplot){
    plot_id <- c('CLST_PLOT')
  }else{
    plot_id <- c('SUB_PLOT')
  }
  
  
  if(table=="tree"){
    
    if (Stockedland){ 
      data <- filter_NFI(data, c("plot$LAND_USECD == 1"))
    }
    
    if(talltree){
      data$tree <- data$tree %>% filter(WDY_PLNTS_TYP_CD == 1)
    }
    
    if(!largetreearea){ 
      data$tree <- data$tree %>% filter(LARGEP_TREE == 0)
    }
    
    
    df <- left_join(data$tree[, c('CLST_PLOT', 'SUB_PLOT', "CYCLE", 'WDY_PLNTS_TYP_CD', 
                                  'basal_area', 'LARGEP_TREE', sp)], 
                    data$plot[,c('CLST_PLOT', 'SUB_PLOT', "CYCLE", 'INVYR', "LAND_USE", "LAND_USECD", grpby)],
                    by = c("CLST_PLOT", "SUB_PLOT", "CYCLE"))
    
    

  }else if(table=="herb"){
    df <- left_join(data$herb[, c('CLST_PLOT', 'SUB_PLOT', "CYCLE", sp)], 
                    data$plot[,c('CLST_PLOT', 'SUB_PLOT', "CYCLE", 'INVYR', "LAND_USE", "LAND_USECD", grpby)],
                    by = c("CLST_PLOT", "SUB_PLOT", "CYCLE"))
    
  }else if(table=="veg"){
    df <- left_join(data$veg[, c('CLST_PLOT', 'SUB_PLOT', "CYCLE", 'VEGPLOT', 'NUMINDI', sp)], 
                    data$plot[,c('CLST_PLOT', 'SUB_PLOT', "CYCLE", 'INVYR', "LAND_USE", "LAND_USECD", grpby)],
                    by = c("CLST_PLOT", "SUB_PLOT", "CYCLE"))
    
    df$NUMINDI <- as.numeric(as.character(df$NUMINDI))
    
  }else if(table=="sapling"){
    
    df <- left_join(data$sapling[, c('CLST_PLOT', 'SUB_PLOT', "CYCLE", 'TREECOUNT', sp)], 
                    data$plot[,c('CLST_PLOT', 'SUB_PLOT', "CYCLE", 'INVYR', "LAND_USE", "LAND_USECD", grpby)],
                    by = c("CLST_PLOT", "SUB_PLOT", "CYCLE"))
    
    df$TREECOUNT <- as.numeric(as.character(df$TREECOUNT))
    
  }else(
    
    stop("param 'table' must be one of c('tree', 'herb', 'veg', 'sapling')")
  )
  
  
  plot_id  <- rlang::sym(plot_id)
  grpby  <- rlang::syms(grpby)
  sp<- rlang::sym(sp)
  

  
  
  ## Calculating Species Diversity-------------------------------------------------------------- 
  
  if(basal & table=="tree"){ # Based on Basal Area at Breast Height 
    
    indices_temp <- df %>%
      group_by(CYCLE, !!plot_id, !!!grpby, !!sp) %>%
      summarise(value = sum(basal_area), .groups = 'drop')
    
  }else{ # Based on Number of Individuals
    
    if(table=="tree"||table== "herb"){
      
      indices_temp <- df %>%
        group_by(CYCLE, !!plot_id, !!!grpby, !!sp) %>%
        summarise(value = n(), .groups = 'drop')
      
    }else if(table=="veg"){
      
      indices_temp <- df %>%
        group_by(CYCLE, !!plot_id, !!!grpby, !!sp) %>%
        summarise(value = sum(NUMINDI), .groups = 'drop')
      
    }else{ #sapling
      
      indices_temp <- df %>%
        group_by(CYCLE, !!plot_id, !!!grpby, !!sp) %>%
        summarise(value = sum(TREECOUNT), .groups = 'drop')
    }
  }
  
  
  indices_temp <- indices_temp %>% tidyr::spread(key = !!sp, value = value )
  
  
  indices <- indices_temp[,1:(length(grpby)+2)]
  abundance.matrix <- indices_temp[,-c(1:(length(grpby)+2))]
  abundance.matrix[is.na(abundance.matrix)] <- 0
  
  indices$Richness <- rowSums(abundance.matrix>0)
  indices$Shannon <- vegan::diversity(abundance.matrix) # shannon is default
  indices$Simpson <- vegan::diversity(abundance.matrix, "simpson")
  indices$Evenness  <- indices$Shannon/log(indices$Richness)
  
  
  if(!byplot){
    
    indices <- indices %>% 
      group_by(CYCLE, !!!grpby) %>% 
      summarise(mean_Richness = mean(Richness , na.rm=TRUE),
                se_Richness =  plotrix::std.error(Richness, na.rm=TRUE),
                mean_Shannon = mean(Shannon, na.rm=TRUE),
                se_Shannon =  plotrix::std.error(Shannon, na.rm=TRUE),
                mean_Simpson = mean(Simpson, na.rm=TRUE),
                se_Simpson =  plotrix::std.error(Simpson, na.rm=TRUE),
                mean_Evenness = mean(Evenness, na.rm=TRUE),
                se_Evenness =  plotrix::std.error(Evenness, na.rm=TRUE),.groups = 'drop')
    
    
  }
  
  
  return(indices)
  
  
}
